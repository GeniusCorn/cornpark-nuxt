# 伤害

## 首先，不造成伤害

软件专业人员的首要承诺是：不造成伤害！这意味着你的代码不能伤害你的用户、你的员工、你的经理，也不能伤害你的程序员同事。

每名程序员都有责任在自己的成熟度和理解程度基础上知道代码做了什么。每名程序员都要对自己的代码所造成的危害负责。

### 对社会无害

首先，你不可对你所处的社会造成危害。

你只需要做出你能做出的最好的决定。良知即指南。

你被聘为程序员的主要理由之一是，你知道事情在什么时候会出错。你有能力在麻烦发生之前找到它。因此，你有责任在可怕的事情发生之前大声说出来。

### 对功能的损害

你必须知道你的代码能工作。你必须知道，代码的运作不会对公司、用户或程序员同事造成伤害。

当风险很高时，应当让你的知识尽可能地接近完成。如果生命受到威胁，你必须知道你的代码不会杀死任何人。如果他人的财富是赌注，你必须知道你的代码不会令它们丢失。

我们很容易低估软件可能造成的伤害，以及你的软件不够重要，不会伤害任何人。事实是，几乎总是有比你想象得更多的风险。

### 对结构无害

不应危害代码结构。应该保持代码整洁，保持代码结构良好。

遗留下的死代码损坏了系统结构，有可能出现有害行为。结构越凌乱，就越难了解代码功用。越混乱，就越不确定。混乱的软件就是有害的软件。

成千上万的全局变量是一种结构性缺陷。留在代码库中的死代码也是如此。结构性伤害是对源代码的组织和内容的伤害。只要使源代码难以阅读、难以理解、难以修改或难以重用，就是结构性危害。

了解良好的软件结构纪律和标准是每个专业软件开发人员的责任。

### 柔软

发明软件的目的是为了使机器的行为易于改动。如果我们的软件难以改动，我们就破坏了软件存在的根本原因。

软件有两个价值，一个是行为的价值，另一个是⌈柔软性⌋的价值。客户和用户希望我们能够很容易地改变这种行为，而且不需要高成本。

没有任何产品能在与用户的接触中幸存下来。一旦你开始把产品交到用户手中，你就会发现它错误百出。而如果你不能在不制造混乱的情况下修改它，你就注定要失败。

### 测试

测试排第一。先写测试，先清理测试。你会知道每一行代码都在工作，因为你已经写好了测试，证明它们在工作。

大多数程序员会同意，实践 TDD 是专业开发者需要遵守的最低限度纪律和行为的一部分。

## 最好的作品

老板的压力无关紧要。真正的压力来自我们的内心。

### 使其正确

软件结构如果难以改变，也就很难跟得上需求变化。结构不好的软件很快就会被淘汰。为了跟上需求变化，软件结构必须足够整洁，允许甚至鼓励变化。

什么时候需求最有可能变更？在项目开始阶段，就在用户看到最初的几个功能完成之后，需求最不稳定。这是因为他们第一次看到了系统的实际功能，而不是他们以为的功能。所以，如果要快速进行早期开发，系统结构在一开始就必须整洁。

### 什么是好结构

有了好结构，系统就容易测试，容易修改，容易重用。对一部分代码的修改不会破坏代码的其他部分。对一个模块的改变不会导致大规模重新编译和重新部署。高层级策略与低层级细节分开，并保持独立。

脆弱是指系统行为的微小变动导致大量模块发生许多相应变动。所谓不可移动，是指某个模块包含了另一个系统中想要的行为，但该模块与当前系统纠缠在一起，无法将其抽离出来并用于新系统。

### 艾森豪威尔矩阵

> 问题有两种，紧急的和重要的。紧急的不重要，而重要的永远不紧急。

> 紧迫性越高，关联性越小。

TDD 是一种设计艺术，而不是一种测试技术。

### 程序员是利益相关者

大多数程序员都不喜欢对抗。但是，与爱对抗的经理打交道是我们必须学习的技能。我们必须学会如何为我们知道是正确的事情而斗争。为重要的事负责，并未这些事情而斗争，是专业人士的行为。

### 尽力而为

尽力而为，不故意发布有害的代码。

## 可重复证据

在每次发布时提供快速、确定和可重复的证据，证明代码的每个元素都能正常工作。

### 正确性证明

只有三种技术可以用来证明算法的正确性，那就是枚举、归纳和抽象。枚举用来证明两个依次排列的语句，或由布尔表达式选择的两个语句是正确的。归纳用来证明一个循环是正确的。抽象用来将一组语句分解成更小的可证明的片段。

### 结构化编程

为了保持代码的可证明性，代码应由三种标准构件组成：

- 顺序：两个或多个按执行顺序排序的语句，即无分支的代码行。
- 条件选择：由断言选择的两个或多个语句，即 if/else 和 switch/case 语句。
- 遍历：由断言控制的重复语句，即 while 和 for 循环。

任何程序，无论多么复杂，可以只由这三种结构组成。由这三种结构组成的程序可被证明。这种技术被称为结构化编程。

### 功能分解

功能分解是指从程序的最高层开始，逐步递归，将其分解为越来越小的可证明单元的过程。

### TDD

每个用 TDD 构建的系统都是由复合结构化编程的功能分解元素构建而成的。测试就是证明，测试就是理论。